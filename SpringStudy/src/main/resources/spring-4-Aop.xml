<?xml version="1.0" encoding="UTF-8"?>

<!--    注意如果需要加入切面特性的话，则必须在 xsi:schemaLocation中加入
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd
        这三个链接否则会报错:"cvc-complex-type.2.4.c: 通配符的匹配很全面, 但无法找到元素 'f_aop:config' 的声明。"-->
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd ">

    <!--    <bean id="moocAspect" class="unused.aop_config.MoocAspect"/>-->
    <!--    <bean id="aspectBiz" class="unused.aop_config.AspectBiz"/>-->

    <!--    <f_aop:config>-->
    <!--        <f_aop:aspect id="moocAspectAop" ref="moocAspect">-->
    <!--            <f_aop:pointcut id="moocPointcut" expression="execution(* unused.aop_config.*Biz.*(..))*"/>-->
    <!--            <f_aop:before method="before" pointcut-ref="moocPointcut"/>-->
    <!--        </f_aop:aspect>-->

    <!--    </f_aop:config>-->

    <!--4. AOP 面向切面的编程
        4.1 Spring 框架的 AOP
            a.面向方面的编程需要把程序逻辑分解成不同的部分称为所谓的关注点。
            跨一个应用程序的多个点的功能被称为横切关注点，这些横切关注点在概念上独立于应用程序的业务逻辑。
            有各种各样的常见的很好的方面的例子，如日志记录、审计、声明式事务、安全性和缓存等。
            b.在 OOP 中，关键单元模块度是类，而在 AOP 中单元模块度是方面。依赖注入帮助你对应用程序对象相互解耦和AOP可以帮助
            你从它们所影响的对象中对横切关注点解耦。AOP是像编程语言的触发物，如 Perl，.NET，Java 或者其他。
            c.Spring AOP 模块提供拦截器来拦截一个应用程序，例如，当执行一个方法时，你可以在方法执行之前或之后添加额外的功能。
            4.1.1 AOP 术语
                项	            描述
                Aspect	        一个模块具有一组提供横切需求的APIs。例如，一个日志模块为了记录日志将被AOP方面调用。
                                应用程序可以拥有任意数量的方面，这取决于需求。
                Join point	    在你的应用程序中它代表一个点，你可以在插件 AOP 方面。你也能说，它是在实际的应用程序中，
                                其中一个操作将使用 Spring AOP 框架。
                Advice	        这是实际行动之前或之后执行的方法。这是在程序执行期间通过 Spring AOP 框架实际被调用的代码。
                Pointcut	    这是一组一个或多个连接点，通知应该被执行。你可以使用表达式或模式指定切入点
                                正如我们将在AOP的例子中看到的。
                Introduction	引用允许你添加新方法或属性到现有的类中。
                Target object	被一个或者多个方面所通知的对象，这个对象永远是一个被代理对象。也称为被通知对象。
                Weaving	        Weaving把方面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。
                                这些可以在编译时，类加载时和运行时完成。

            4.2.2 通知类型
                    Spring 方面可以使用下面提到的五种通知工作：
                通知	            描述
                前置通知	        在一个方法执行之前，执行通知。
                后置通知	        在一个方法执行之后，不考虑其结果，执行通知。
                返回后通知	    在一个方法执行之后，只有在方法成功完成时，才能执行通知。
                抛出异常后通知	在一个方法执行之后，只有在方法退出抛出异常时，才能执行通知。
                环绕通知	        在建议方法调用之前和之后，执行通知。

            4.2.3 实现切面的方式
                    Spring支持@AspectJ annotation style 的方法和基于模式的方法来实现自定义方面。
                这两种方法已经在下面两个子节进行了详细解释。
                方法	                        描述
                XML Schema based	        方面是使用常规类以及基于配置的 XML 来实现的。
                @AspectJ based	            @AspectJ 引用一种声明方面的风格作为带有 Java 5 注释的常规 Java 类注释。
    -->

    <!--4.2 Spring 中基于 AOP 的 XML架构
        一个切入点有助于确定使用不同建议执行的感兴趣的连接点（即方法）。
        在处理基于配置的 XML 架构时，切入点将会按照如下所示定义：-->
    <!--4.2.1声明一个aspect-->
    <!--    <f_aop:config>-->
    <!--        <f_aop:aspect id="myAspect" ref="aBean">-->
    <!--            ...-->
    <!--        </f_aop:aspect>-->
    <!--    </f_aop:config>-->

    <!--4.2.2声明一个切入点-->
    <!--    <f_aop:config>-->
    <!--        <f_aop:aspect id="myAspect" ref="aBean">-->
    <!--            <f_aop:pointcut id="businessService"-->
    <!--                          expression="execution(* com.tutorialspoint.XmlStudent.getName(..))"/>-->
    <!--            ...-->
    <!--        </f_aop:aspect>-->
    <!--    </f_aop:config>-->

    <aop:config>
        <aop:aspect id="xmlLog" ref="xmlLog">
            <!--该execution可以精确到每一个类中的方法，也可以发现，该execution包含的路径中可能有切面本身的业务代码，
            但是spring可以自动识别。-->
            <!--<f_aop:pointcut id="xmlSelectAll" expression="execution(* f_aop.by_1_xml.*.*(..))"/>-->
            <aop:pointcut id="xmlSelectAll" expression="execution(* f_aop.by_1_xml.XmlStudent.*(..))"/>
            <aop:before pointcut-ref="xmlSelectAll" method="beforeAdvice"/>
            <aop:after pointcut-ref="xmlSelectAll" method="afterAdvice"/>
            <aop:after-returning pointcut-ref="xmlSelectAll" returning="retVal" method="afterReturningAdvice"/>
            <!--AfterThrowingAdvice注意该方法首字母大写了，因为方法名不规范所致-->
            <aop:after-throwing pointcut-ref="xmlSelectAll" throwing="ex" method="AfterThrowingAdvice"/>
        </aop:aspect>
    </aop:config>

    <!-- 这里定义了目标业务类的位置 -->
    <bean id="xmlStudent" class="f_aop.by_1_xml.XmlStudent">
        <property name="name" value="XmlStudent"/>
        <property name="age" value="10"/>
    </bean>

    <!-- 这里定义了切片的处理类的位置 -->
    <bean id="xmlLog" class="f_aop.by_1_xml.XmlLogging"/>


    <!--4.3 Spring 中基于 AOP 的 @AspectJ-->
    <!--用于标识面向切片的处理-->
    <aop:aspectj-autoproxy/>
    <!-- 这里定义了目标业务类的位置 -->
    <bean id="aspectJStudent" class="f_aop.by_2_aspectj.AspectJStudent">
        <property name="name"  value="aspectJStudent" />
        <property name="age"  value="11"/>
    </bean>

    <!-- 这里定义了切片的处理类的位置 -->
    <bean id="aspectJLogging" class="f_aop.by_2_aspectj.AspectJLogging"/>
</beans>
